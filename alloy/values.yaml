# -- Overrides for the chart's name or fullname, if required
nameOverride: null
fullnameOverride: null

global:
  image:
    registry: ""
    pullSecrets: []

# -- Manage CRDs for monitoring
crds:
  create: true

# -- Alloy-specific configuration
alloy:
  configMap:
    create: true  # Create a new ConfigMap for Prometheus scraping configuration
    content: |
      # Scrape metrics from node-exporter
      prometheus.scrape "node_exporter" {
        targets = [{
          __address__ = "node-exporter-prometheus-node-exporter.alloy.svc.cluster.local:9100"
        }]
        forward_to = [prometheus.remote_write.mimir.receiver]
        job_name   = "node_exporter"
      }

      # Scrape metrics from kube-state-metrics
      prometheus.scrape "kube-state-metrics" {
        targets = [{
          __address__ = "kube-state-metrics.kube-system.svc.cluster.local:8080"
        }]
        forward_to = [prometheus.remote_write.mimir.receiver]
        job_name   = "kube-state-metrics"
      }

      # Scrape metrics from kubelet
      prometheus.scrape "kubelet" {
        targets = [{
          __address__ = "kubelet.kube-system.svc.cluster.local:10250"
        }]
        forward_to = [prometheus.remote_write.mimir.receiver]
        job_name   = "kubelet"
      }

      # Scrape metrics from Kubernetes API server
      prometheus.scrape "apiserver" {
        targets = [{
          __address__ = "kubernetes.default.svc.cluster.local:443"
        }]
        forward_to = [prometheus.remote_write.mimir.receiver]
        job_name   = "kubernetes-apiserver"
      }

      # Loki: Send logs to external Loki
      loki.push "loki" {
        endpoint = "http://loki-dev-loki-distributed-gateway.loki.svc.cluster.local/loki/api/v1/push"
        labels   = { job = "kubernetes-logs" }
      }

      # Tempo: Send traces to external Tempo
      tempo.push "tempo" {
        endpoint = "http://tempo-dev-distributed-distributor.tempo-dev.svc:3200/api/traces"
      }

      # Remote write configuration to Mimir
      prometheus.remote_write "mimir" {
        endpoint {
          name = "mimir-distributor"
          url  = "http://mimir-dev-nginx.mimir-dev.svc:80/api/v1/push"

          queue_config {
            capacity             = 5000
            max_shards           = 300
            max_samples_per_send = 1000
          }

          metadata_config {
            max_samples_per_send = 1000
          }
        }
      }

  clustering:
    enabled: false  # Disable clustering for now
    name: ""  # Optional: set a name if clustering is enabled

  storagePath: /tmp/alloy
  listenAddr: 0.0.0.0
  listenPort: 12345
  listenScheme: HTTP
  uiPathPrefix: /
  enableReporting: true  # Enable anonymous usage stats reporting

  extraEnv: []
  envFrom: []
  extraArgs: []
  extraPorts: []

  mounts:
    varlog: true       # Enable access to log directory
    dockercontainers: true  # Enable access to Docker container logs
    extra: []

  resources: {}  # Define resource limits/requests here if needed

controller:
  type: 'daemonset'  # DaemonSet to ensure one pod per node
  replicas: 1  # Ignored if using daemonset

  extraAnnotations: {}
  hostNetwork: false
  dnsPolicy: ClusterFirst
  terminationGracePeriodSeconds: 30

  nodeSelector: {}
  tolerations: []
  affinity: {}
  updateStrategy: {}
  priorityClassName: ''
  podAnnotations: {}
  podLabels: {}

  podDisruptionBudget:
    enabled: false

  autoscaling:
    enabled: false

service:
  enabled: true
  type: ClusterIP
  nodePort: 31128
  clusterIP: ''
  internalTrafficPolicy: Cluster
  annotations: {}

serviceAccount:
  create: true
  additionalLabels: {}
  annotations: {}
  name: null

rbac:
  create: true

configReloader:
  enabled: true
  image:
    registry: "ghcr.io"
    repository: jimmidyson/configmap-reload
    tag: v0.12.0
  resources:
    requests:
      cpu: "1m"
      memory: "5Mi"

ingress:
  enabled: false
  annotations: {}
  labels: {}
  path: /
  faroPort: 12347
  pathType: Prefix
  hosts:
    - chart-example.local
  tls: []
